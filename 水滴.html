<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>點擊產生水滴 Demo</title>
  <style>
    html,body{height:100%;margin:0;background:#0b1220;}
    canvas{display:block;width:100%;height:100%;}
    /* 少量 UI */
    .hint{
      position:fixed;left:12px;top:12px;color:rgba(255,255,255,0.85);font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans CJK TC", "PingFang TC", "Microsoft JhengHei";background:rgba(0,0,0,0.25);padding:8px 10px;border-radius:8px;backdrop-filter:blur(4px);
    }
  </style>
</head>
<body>
  <div class="hint">點擊或觸控任意位置，會有水滴掉落與濺起效果</div>
  <canvas id="c"></canvas>

  <script>
    // 初始化畫布與尺寸
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    function fitCanvas(){
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(innerWidth * dpr);
      canvas.height = Math.floor(innerHeight * dpr);
      canvas.style.width = innerWidth + 'px';
      canvas.style.height = innerHeight + 'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    fitCanvas();
    window.addEventListener('resize', fitCanvas);

    // 物件陣列
    const drops = [];
    const particles = [];

    // 常數（可調）
    const GRAVITY = 0.45;        // 重力加速度
    const AIR_RESIST = 0.995;    // 空氣阻力
    const FLOOR_Y = innerHeight - 10; // 底部（會在resize時更新）

    function updateFloor(){
      // 重新讀取 innerHeight
    }
    window.addEventListener('resize', ()=>{ /* kept for potential future use */ });

    // 水滴類別
    class Drop {
      constructor(x,y){
        this.x = x;
        this.y = y;
        this.r = 6 + Math.random()*6; // 半徑
        this.vy = 2 + Math.random()*2; // 初速度
        this.vx = (Math.random()-0.5)*1.5;
        this.bounced = false;
        this.opacity = 0.95;
      }
      step(){
        this.vy += GRAVITY * (this.r/10) * 0.7; // 大一點的滴比較受重力影響
        this.vx *= AIR_RESIST;
        this.vy *= AIR_RESIST;
        this.x += this.vx;
        this.y += this.vy;

        // 撞地檢測
        if(this.y + this.r >= innerHeight - 6){
          // 濺起微小粒子
          this.splash();
          // 消失（或輕微反彈）
          this.opacity = 0;
          return false; // 表示要移除
        }
        // 若移出畫面
        if(this.x < -50 || this.x > innerWidth + 50 || this.y > innerHeight + 200) return false;
        return true;
      }
      splash(){
        const count = 8 + Math.floor(Math.random()*6);
        for(let i=0;i<count;i++){
          const angle = Math.PI * (0.2 + Math.random()*0.6);
          const dir = (Math.random()<0.5? -1:1);
          const speed = 2 + Math.random()*4;
          particles.push(new Particle(this.x, innerHeight - 6, Math.cos(angle)*speed*dir, -Math.sin(angle)*speed, this.r*0.35));
        }
      }
      draw(ctx){
        const grd = ctx.createRadialGradient(this.x-1, this.y-1, this.r*0.1, this.x, this.y, this.r);
        grd.addColorStop(0, 'rgba(255,255,255,0.95)');
        grd.addColorStop(0.35, 'rgba(180,220,255,0.9)');
        grd.addColorStop(1, 'rgba(30,120,200,0.25)');
        ctx.beginPath();
        ctx.fillStyle = grd;
        ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // 濺起粒子
    class Particle {
      constructor(x,y,vx,vy,r){
        this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.r = r; this.life= 50 + Math.random()*40; this.alpha = 1;
      }
      step(){
        this.vy += GRAVITY*0.25;
        this.vx *= 0.99;
        this.vy *= 0.995;
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 1;
        if(this.y > innerHeight - 6) this.life = 0; // 落地即消失
        this.alpha = Math.max(0, this.life/80);
        return this.life>0;
      }
      draw(ctx){
        ctx.beginPath();
        ctx.globalAlpha = this.alpha;
        ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(150,200,255,0.9)';
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    // 動畫回圈
    function animate(){
      ctx.clearRect(0,0,innerWidth,innerHeight);

      // 微微畫出背景漸層（更有深度）
      const bg = ctx.createLinearGradient(0,0,0,innerHeight);
      bg.addColorStop(0,'#07101a');
      bg.addColorStop(1,'#071125');
      ctx.fillStyle = bg;
      ctx.fillRect(0,0,innerWidth,innerHeight);

      // 更新與繪製 drops
      for(let i = drops.length-1; i>=0; i--){
        const d = drops[i];
        const alive = d.step();
        if(!alive) drops.splice(i,1);
        else d.draw(ctx);
      }

      // 更新與繪製 particles
      for(let i = particles.length-1; i>=0; i--){
        const p = particles[i];
        const alive = p.step();
        if(!alive) particles.splice(i,1);
        else p.draw(ctx);
      }

      // 底部微光（模擬水面）
      ctx.save();
      ctx.globalAlpha = 0.12;
      ctx.fillStyle = 'rgba(180,220,255,0.08)';
      ctx.fillRect(0, innerHeight-6, innerWidth, 6);
      ctx.restore();

      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // 監聽點擊與觸控
    function spawnDropAt(clientX, clientY){
      const rect = canvas.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      // 產生 1~3 個水滴，讓效果更豐富
      const count = 1 + Math.floor(Math.random()*3);
      for(let i=0;i<count;i++){
        const dx = x + (Math.random()-0.5)*20;
        const dy = y + (Math.random()-0.5)*8;
        drops.push(new Drop(dx, dy));
      }
    }

    canvas.addEventListener('mousedown', (e)=>{ spawnDropAt(e.clientX, e.clientY); });
    canvas.addEventListener('touchstart', (e)=>{
      e.preventDefault();
      for(const t of e.touches) spawnDropAt(t.clientX, t.clientY);
    }, {passive:false});

    // 也支援滑鼠按下後拖曳會連續掉
    let isDown = false;
    canvas.addEventListener('mousedown', ()=> isDown = true);
    window.addEventListener('mouseup', ()=> isDown = false);
    canvas.addEventListener('mousemove', (e)=>{ if(isDown) spawnDropAt(e.clientX, e.clientY); });

    // 初始貼心提示（短暫）
    setTimeout(()=>{
      const hint = document.querySelector('.hint');
      if(hint) hint.style.opacity = '0.6';
    },2500);

  </script>
</body>
</html>
